Реализовано два алгоритма - поиск кратчайшего пути в неориентированном невзвешенном графе,а также алгоритм приближенной раскраски графа.

Граф представлен в виде класса,полем которого является массив пар - номер вершины и массива её окрестности.То есть граф представлен списками смежности.Такое представление выбрано потому,что в обоих задачах,решенных в данной лабораторной работе,не требуется удалять вершины или каким то образом изменять ребра между ними.

Класс имеет конструктор,принимающий на вход поток для чтения из файла,с помощью данных из которого будет произведено заполнение массива списков смежности.

Алгоритм поиска кратчайшего пути(волновой алгоритм)
Функция поиска кратчайшего пути принимает в качестве параметров два целых числа - номера стартовой и финишной вершин.
Инициализируем массив dist размером количество вершин + 1(тк нумерация вершин начинается с 1) максимальным значением,возможным в типе int.

Инициализируем аналогично массив prev - массив предков вершин,с его помощью мы сможем восстановить ответ(кратчайший путь).

В массиве dist инициализируем значение по индексу start нулем из соображений того,что расстояние от вершины до неё самое равно нулю.

В очереди queue мы будем хранить те вершины,которые будем обрабатывать в порядке FIFO.

Поместим в наше очередь элемент start.

До тех пор,пока очередь не пуста,мы будем производить обработку вершин.
Буквально это значит следующее - извлекаем в переменную u из очереди некоторую вершину,затем в цикле мы проходим по всем вершинам из её окрестности и проверяем,вычисляли ли мы для неё расстояние(равенство на бесконечность).
Обозначим перебираемые вершины как 
v = graph.Get(u).Get(i).
Если нет,то мы считаем,что теперь v (вершина из окрестности u) является следующей за v,значит теперь u считается предком для v,записываем эту информацию в массив prev.
Также мы должны обновить расстояние до вершины v,ведь теперь мы считаем,что путь до вершины v складывается из пути до её предка(вершины u) плюс вес ребра между ними(так как граф невзвешенный,то вес ребра равен 1).
И,конечно же,помещаем вершину v в нашу очередь для дальшейшей обработки.

И,наконец,мы восстанавливаем ответ с помощью массива предков (prev).

---------------------------------------------------------------------------------------------------------------------------------------------------

Приближенная раскраска графа

Функция вычисления приближенной раскраски графа принимает по ссылке объект класса Graph.

Инициализируем массив пар tmp_graph,куда мы запишем отсортированные по степени вершины.

Также инициализируем массив vert,где будем хранить номера вершин в порядке возрастания степеней.

И наконец инициализируем массив пар число - символ для формирования нашего ответа.

Ответ будет выведен в виде списка "номер вершины - символ",где символ будет обозначать уникальный цвет,в который покрашена одна или несколько вершин.

Начнем обозначать цвета латинской буквой "A",далее при необходимости с помощью таблицы ASCII будем двигаться по алфавиту дальше.

С помощью тройного цикла произведем эвристическую раскраску.Ранее мы отсортировали вершины по возрастанию степени,это позволит нам быстрее произвести её.

В первом цикле фиксируется номер рассматриваемой для раскраски вершины.Если она ещё не была раскрашена - происходит раскраска.
Во втором цикле мы фиксируем количество вершин,проверяемых на смежность с текущей вершиной.
И,наконец,в третьем цикле происходит проверка того,что никакая вершина не смежна с текущей,иначе мы ничего не красим.

После окончания раскраски возвращается массив ans.